diff --git a/_upgrade_staging/scintilla/src/ViewStyle.cxx b/scintilla/src/ViewStyle.cxx
index 92d084ee6..f1301aec5 100644
--- a/_upgrade_staging/scintilla/src/ViewStyle.cxx
+++ b/scintilla/src/ViewStyle.cxx
@@ -61,9 +61,12 @@ bool MarginStyle::ShowsFolding() const noexcept {
 
 void FontRealised::Realise(Surface &surface, int zoomLevel, Technology technology, const FontSpecification &fs, const char *localeName) {
 	PLATFORM_ASSERT(fs.fontName);
-	measurements.sizeZoomed = fs.size + zoomLevel * FontSizeMultiplier;
-	if (measurements.sizeZoomed <= FontSizeMultiplier)	// May fail if sizeZoomed < 1
-		measurements.sizeZoomed = FontSizeMultiplier;
+	// >>>>>>>>>>>>>>>   BEG NON STD SCI PATCH   >>>>>>>>>>>>>>>
+	//~measurements.sizeZoomed = fs.size + zoomLevel * FontSizeMultiplier;
+	//~if (measurements.sizeZoomed <= FontSizeMultiplier)	// May fail if sizeZoomed < 1
+	//~	measurements.sizeZoomed = FontSizeMultiplier;
+	measurements.sizeZoomed = GetFontSizeZoomed(fs.size, zoomLevel);
+	// <<<<<<<<<<<<<<<   END NON STD SCI PATCH   <<<<<<<<<<<<<<<
 
 	const float deviceHeight = static_cast<float>(surface.DeviceHeightFont(measurements.sizeZoomed));
 	const FontParameters fp(fs.fontName, deviceHeight / FontSizeMultiplier, fs.weight,
@@ -225,7 +228,9 @@ ViewStyle::ViewStyle(size_t stylesSize_) :
 	marginInside = true;
 	CalculateMarginWidthAndMask();
 	textStart = marginInside ? fixedColumnWidth : leftMarginWidth;
-	zoomLevel = 0;
+	// >>>>>>>>>>>>>>>   BEG NON STD SCI PATCH   >>>>>>>>>>>>>>>
+	zoomLevel = 100;  /// @ 20018-09-06 Changed to percent
+	// <<<<<<<<<<<<<<<   END NON STD SCI PATCH   <<<<<<<<<<<<<<<
 	viewWhitespace = WhiteSpace::Invisible;
 	tabDrawMode = TabDrawMode::LongArrow;
 	whitespaceSize = 1;
@@ -413,11 +418,9 @@ void ViewStyle::Refresh(Surface &surface, int tabInChars) {
 	maxAscent = std::max(1.0, maxAscent + extraAscent);
 	maxDescent = std::max(0.0, maxDescent + extraDescent);
 	lineHeight = static_cast<int>(std::lround(maxAscent + maxDescent));
-	lineOverlap = lineHeight / 10;
-	if (lineOverlap < 2)
-		lineOverlap = 2;
-	if (lineOverlap > lineHeight)
-		lineOverlap = lineHeight;
+	// >>>>>>>>>>>>>>>   BEG NON STD SCI PATCH   >>>>>>>>>>>>>>>
+	lineOverlap = std::clamp(lineHeight / 10, 1, std::max(1, lineHeight));
+	// <<<<<<<<<<<<<<<   END NON STD SCI PATCH   <<<<<<<<<<<<<<<
 
 	someStylesProtected = std::any_of(styles.cbegin(), styles.cend(),
 		[](const Style &style) noexcept { return style.IsProtected(); });
@@ -427,7 +430,10 @@ void ViewStyle::Refresh(Surface &surface, int tabInChars) {
 
 	aveCharWidth = styles[StyleDefault].aveCharWidth;
 	spaceWidth = styles[StyleDefault].spaceWidth;
-	tabWidth = spaceWidth * tabInChars;
+	// >>>>>>>>>>>>>>>   BEG NON STD SCI PATCH   >>>>>>>>>>>>>>>
+	//~tabWidth = spaceWidth * tabInChars;
+	tabWidth = aveCharWidth * tabInChars;
+	// <<<<<<<<<<<<<<<   END NON STD SCI PATCH   <<<<<<<<<<<<<<<
 
 	controlCharWidth = 0.0;
 	if (controlCharSymbol >= 32) {
@@ -761,6 +767,44 @@ ViewStyle::CaretShape ViewStyle::CaretShapeForMode(bool inOverstrike, bool isMai
 	return (caretStyle <= CaretStyle::Block) ? static_cast<CaretShape>(caretStyle) : CaretShape::line;
 }
 
+// >>>>>>>>>>>>>>>   BEG NON STD SCI PATCH   >>>>>>>>>>>>>>>
+bool ViewStyle::ZoomIn() noexcept {
+	if (zoomLevel < SC_MAX_ZOOM_LEVEL) {
+		int level = zoomLevel;
+		if (level < 200) {
+			level += 10;
+		} else {
+			level += 25;
+		}
+
+		level = std::min(level, SC_MAX_ZOOM_LEVEL);
+		if (level != zoomLevel) {
+			zoomLevel = level;
+			return true;
+		}
+	}
+	return false;
+}
+
+bool ViewStyle::ZoomOut() noexcept {
+	if (zoomLevel > SC_MIN_ZOOM_LEVEL) {
+		int level = zoomLevel;
+		if (level <= 200) {
+			level -= 10;
+		} else {
+			level -= 25;
+		}
+
+		level = std::max(level, SC_MIN_ZOOM_LEVEL);
+		if (level != zoomLevel) {
+			zoomLevel = level;
+			return true;
+		}
+	}
+	return false;
+}
+// <<<<<<<<<<<<<<<   END NON STD SCI PATCH   <<<<<<<<<<<<<<<
+
 void ViewStyle::AllocStyles(size_t sizeNew) {
 	size_t i=styles.size();
 	styles.resize(sizeNew);
@@ -782,10 +826,10 @@ void ViewStyle::CreateAndAddFont(const FontSpecification &fs) {
 	}
 }
 
-FontRealised *ViewStyle::Find(const FontSpecification &fs) {
+FontRealised *ViewStyle::Find(const FontSpecification &fs) const {
 	if (!fs.fontName)	// Invalid specification so return arbitrary object
 		return fonts.begin()->second.get();
-	const FontMap::iterator it = fonts.find(fs);
+	const auto it = fonts.find(fs);
 	if (it != fonts.end()) {
 		// Should always reach here since map was just set for all styles
 		return it->second.get();
